[
  {
    "code": "def calculate_average(numbers):\n    total = 0\n    for num in numbers:\n        total += num\n    return total / len(numbers)\n\nresult = calculate_average([])\nprint(result)",
    "bugLine": 5,
    "bugDescription": "ZeroDivisionError: Division by zero occurs if an empty list is passed, as len(numbers) will be 0."
  },
  {
    "code": "def remove_duplicates(items):\n    result = []\n    for item in items:\n        if item not in result:\n            result.append(item)\n    return results\n\nmy_list = [1, 2, 2, 3, 4, 4, 5]\nunique_items = remove_duplicates(my_list)\nprint(unique_items)",
    "bugLine": 6,
    "bugDescription": "NameError: The variable 'results' is referenced before assignment (typo, should be 'result')."
  },
  {
    "code": "numbers = [1, 2, 3]\nprint(numbers[3])",
    "bugLine": 2,
    "bugDescription": "IndexError: list index out of range because the list has only three elements (indices 0-2)."
  },
  {
    "code": "text = 'Hello' + 5\nprint(text)",
    "bugLine": 1,
    "bugDescription": "TypeError: can only concatenate str (not \"int\") to str"
  },
  {
    "code": "print(unknown_var)",
    "bugLine": 1,
    "bugDescription": "NameError: name 'unknown_var' is not defined"
  },
  {
    "code": "result = 10 / 0\nprint(result)",
    "bugLine": 1,
    "bugDescription": "ZeroDivisionError: division by zero"
  },
  {
    "code": "d = {'x': 10}\nprint(d['y'])",
    "bugLine": 2,
    "bugDescription": "KeyError: 'y'"
  },
  {
    "code": "lst = [1, 2]\nlst.append_method(3)",
    "bugLine": 2,
    "bugDescription": "AttributeError: 'list' object has no attribute 'append_method'"
  },
  {
    "code": "num = int('abc')\nprint(num)",
    "bugLine": 1,
    "bugDescription": "ValueError: invalid literal for int() with base 10: 'abc'"
  },
  {
    "code": "def func()\n    return 1",
    "bugLine": 1,
    "bugDescription": "SyntaxError: invalid syntax (missing colon after function definition)"
  },
  {
    "code": "if True:\nprint('Oops')",
    "bugLine": 2,
    "bugDescription": "IndentationError: expected an indented block"
  },
  {
    "code": "def greet(name):\n    return f'Hi, {name}'\ngreet()",
    "bugLine": 3,
    "bugDescription": "TypeError: greet() missing 1 required positional argument: 'name'"
  },
  {
    "code": "empty = []\nprint(empty[0])",
    "bugLine": 2,
    "bugDescription": "IndexError: list index out of range"
  },
  {
    "code": "data = {}\nprint(data['key'])",
    "bugLine": 2,
    "bugDescription": "KeyError: 'key'"
  },
  {
    "code": "class Test:\n    pass\nobj = Test()\nobj.missing",
    "bugLine": 4,
    "bugDescription": "AttributeError: 'Test' object has no attribute 'missing'"
  },
  {
    "code": "print(x)\nx = 10",
    "bugLine": 1,
    "bugDescription": "NameError: name 'x' is not defined"
  },
  {
    "code": "value = 42\nvalue()",
    "bugLine": 2,
    "bugDescription": "TypeError: 'int' object is not callable"
  },
  {
    "code": "a = 5\nb = 0\nprint(a / b)",
    "bugLine": 3,
    "bugDescription": "ZeroDivisionError: division by zero"
  },
  {
    "code": "x, y = [1, 2, 3]",
    "bugLine": 1,
    "bugDescription": "ValueError: too many values to unpack (expected 2)"
  },
  {
    "code": "lst = [1, 2]\nprint(lst[-3])",
    "bugLine": 2,
    "bugDescription": "IndexError: list index out of range"
  },
  {
    "code": "d = {'k': 1}\ndel d['k']\nprint(d['k'])",
    "bugLine": 3,
    "bugDescription": "KeyError: 'k'"
  },
  {
    "code": "s = 'text'\ns[1] = 'a'",
    "bugLine": 2,
    "bugDescription": "TypeError: 'str' object does not support item assignment"
  },
  {
    "code": "def func():\n    print(local_var)\nlocal_var = 5\nfunc()",
    "bugLine": 2,
    "bugDescription": "NameError: name 'local_var' is not defined"
  },
  {
    "code": "[10 / x for x in [2, 1, 0]]",
    "bugLine": 1,
    "bugDescription": "ZeroDivisionError: division by zero"
  },
  {
    "code": "import math\nx = float('nan')\nint(x)",
    "bugLine": 3,
    "bugDescription": "ValueError: cannot convert float NaN to integer"
  },
  {
    "code": "t = (1, 2)\nprint(t[2])",
    "bugLine": 2,
    "bugDescription": "IndexError: tuple index out of range"
  },
  {
    "code": "d = {'a': 1}\nprint(d['b'])",
    "bugLine": 2,
    "bugDescription": "KeyError: 'b'"
  },
  {
    "code": "x = None\nx.upper()",
    "bugLine": 2,
    "bugDescription": "AttributeError: 'NoneType' object has no attribute 'upper'"
  },
  {
    "code": "lst = [1, 2]\nresult = lst + 3",
    "bugLine": 2,
    "bugDescription": "TypeError: can only concatenate list (not \"int\") to list"
  },
  {
    "code": "x = 10\ndel x\nprint(x)",
    "bugLine": 3,
    "bugDescription": "NameError: name 'x' is not defined"
  },
  {
    "code": "def div(x, y):\n    return x / y\ndiv(5, 0)",
    "bugLine": 2,
    "bugDescription": "ZeroDivisionError: division by zero"
  },
  {
    "code": "s = '123'\nprint(f'{s:x}')",
    "bugLine": 2,
    "bugDescription": "ValueError: Unknown format code 'x' for object of type 'str'"
  },
  {
    "code": "s = 'hi'\nprint(s[2])",
    "bugLine": 2,
    "bugDescription": "IndexError: string index out of range"
  },
  {
    "code": "d = {'x': 1}\nd.pop('x')\nprint(d['x'])",
    "bugLine": 3,
    "bugDescription": "KeyError: 'x'"
  },
  {
    "code": "import math\nmath.unknown",
    "bugLine": 2,
    "bugDescription": "AttributeError: module 'math' has no attribute 'unknown'"
  },
  {
    "code": "d = {'a': 1}\nd[0] = 2",
    "bugLine": 2,
    "bugDescription": "TypeError: 'dict' object does not support item assignment with integer keys (this is valid syntax but conceptually a misuse)"
  },
  {
    "code": "def test():\n    print(y)\ntest()",
    "bugLine": 2,
    "bugDescription": "NameError: name 'y' is not defined"
  },
  {
    "code": "for i in range(2):\n    if i == 1:\n        print(1 / 0)",
    "bugLine": 3,
    "bugDescription": "ZeroDivisionError: division by zero"
  },
  {
    "code": "a, b = [1]",
    "bugLine": 1,
    "bugDescription": "ValueError: not enough values to unpack (expected 2, got 1)"
  },
  {
    "code": "lst = [1, 2, 3]\nprint(lst[4])",
    "bugLine": 2,
    "bugDescription": "IndexError: list index out of range"
  },
  {
    "code": "d = {}\nprint(d['x'])",
    "bugLine": 2,
    "bugDescription": "KeyError: 'x'"
  },
  {
    "code": "x = 'test'\nx[0] = 'T'",
    "bugLine": 2,
    "bugDescription": "TypeError: 'str' object does not support item assignment"
  },
  {
    "code": "lst = [1, 2]\nlst[-3]",
    "bugLine": 2,
    "bugDescription": "IndexError: list index out of range"
  },
  {
    "code": "d = {'a': 1}\ndel d['a']\nd['a']",
    "bugLine": 3,
    "bugDescription": "KeyError: 'a'"
  },
  {
    "code": "x = None\nx.method()",
    "bugLine": 2,
    "bugDescription": "AttributeError: 'NoneType' object has no attribute 'method'"
  },
  {
    "code": "a = [1]\na + 2",
    "bugLine": 2,
    "bugDescription": "TypeError: can only concatenate list (not \"int\") to list"
  },
  {
    "code": "z = 5\ndel z\nprint(z)",
    "bugLine": 3,
    "bugDescription": "NameError: name 'z' is not defined"
  },
  {
    "code": "def calc(x):\n    return x / 0\ncalc(10)",
    "bugLine": 2,
    "bugDescription": "ZeroDivisionError: division by zero"
  },
  {
    "code": "num = int('xyz')",
    "bugLine": 1,
    "bugDescription": "ValueError: invalid literal for int() with base 10: 'xyz'"
  },
  {
    "code": "s = 'hello'\ns[5]",
    "bugLine": 2,
    "bugDescription": "IndexError: string index out of range"
  },
  {
    "code": "d = {'k': 1}\nd.pop('k')\nd['k']",
    "bugLine": 3,
    "bugDescription": "KeyError: 'k'"
  },
  {
    "code": "class Example:\n    pass\ne = Example()\ne.no_attr",
    "bugLine": 4,
    "bugDescription": "AttributeError: 'Example' object has no attribute 'no_attr'"
  },
  {
    "code": "def remove_duplicates_in_place(lst):\n    seen = set()\n    for i in range(len(lst)):\n        if lst[i] in seen:\n            del lst[i]\n        else:\n            seen.add(lst[i])\n    return lst\n\nnumbers = [1, 2, 2, 3, 3, 4, 5, 5]\nresult = remove_duplicates_in_place(numbers)\nprint(result)  # Expected [1, 2, 3, 4, 5], but gets IndexError or skips elements",
    "bugLine": 5,
    "bugDescription": "Deleting elements from the list while iterating over it with a fixed range causes the loop to skip elements or raise an IndexError because the list length changes but the range does not adjust."
  },
  {
    "code": "def factorial_with_check(n):\n    def factorial(n):\n        if n <= 1:\n            return n\n        return n * factorial(n - 1)\n    if n < 0:\n        return \"Negative numbers not allowed\"\n    result = factorial(n)\n    return result\n\nprint(factorial_with_check(0))  # Expected 1, but gets 0",
    "bugLine": 4,
    "bugDescription": "The base case returns `n` when `n <= 1`, so `factorial(0)` returns 0 instead of 1, which is incorrect for factorial where 0! = 1."
  },
  {
    "code": "def count_words(text):\n    word_dict = {}\n    lines = text.split('\\n')\n    for line in lines:\n        words = line.split()\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n    return word_dict\n\nsample = \"Hello world\\nHELLO there\\nWorld\"\nresult = count_words(sample)\nprint(result)  # Expected {'hello': 2, 'world': 2, 'there': 1} (case-insensitive), but gets {'Hello': 1, 'world': 1, 'HELLO': 1, 'there': 1, 'World': 1}",
    "bugLine": 7,
    "bugDescription": "The function does not convert words to a consistent case (e.g., lowercase) before counting, treating 'Hello' and 'HELLO' as different keys."
  },
  {
    "code": "def calculate_average_grades(grades):\n    total = 0\n    count = 0\n    for student in grades:\n        for grade in student:\n            total += grade\n            count += 1\n    if count > 0:\n        return total / count\n    return 0\n\nscores = [[85, 90], [], [95, 88]]\nresult = calculate_average_grades(scores)\nprint(result)  # Expected 89.5, but skips empty lists correctly, no bug here, let’s add one\n\ndef calculate_average_grades(grades):\n    total = 0\n    count = 0\n    for student in grades:\n        for grade in student:\n            total += grade\n        count += len(student)\n    if count > 0:\n        return total / count\n    return 0\n\nscores = [[85, 90], [], [95, 88]]\nresult = calculate_average_grades(scores)\nprint(result)  # Expected 89.5, but gets wrong average due to count mismatch",
    "bugLine": 22,
    "bugDescription": "The count is incremented by the length of each sublist, even empty ones, but total only includes actual grades, leading to an incorrect average."
  },
  {
    "code": "def find_longest_sequence(numbers):\n    if not numbers:\n        return 0\n    current_length = 1\n    max_length = 1\n    for i in range(1, len(numbers)):\n        if numbers[i] == numbers[i - 1] + 1:\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 1\n    return max_length\n\nseq = [1, 2, 3, 5, 6, 7, 8]\nresult = find_longest_sequence(seq)\nprint(result)  # Expected 4 (from 5,6,7,8), but gets 3",
    "bugLine": 7,
    "bugDescription": "The `max_length` update is inside the if block, so it only updates when the sequence continues, missing the final sequence length when it ends."
  },
  {
    "code": "def process_data(data):\n    result = []\n    temp = 0\n    for i in range(len(data)):\n        if i % 2 == 0:\n            temp += data[i]\n        else:\n            temp *= data[i]\n            result.append(temp)\n            temp = 0\n    return result\n\nvalues = [1, 2, 3, 4, 5, 6]\noutput = process_data(values)\nprint(output)  # Expected [2, 12, 30], but gets [2, 12] because odd length leaves last pair incomplete",
    "bugLine": 9,
    "bugDescription": "The function only appends when i is odd, so if the list has an odd length, the last even-indexed element’s computation is never added to result."
  },
  {
    "code": "def matrix_sum(matrix):\n    total = 0\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            total += matrix[i][j]\n    return total\n\ndef create_matrix(rows, cols):\n    return [[i * j for j in range(cols)] for i in range(rows)]\n\nmat = create_matrix(3, 4)\nresult = matrix_sum(mat)\nprint(result)  # Expected 60 (sum of 0,0,0,0,0,1,2,3,0,2,4,6), but works fine, let’s add bug\n\ndef matrix_sum_buggy(matrix):\n    total = 0\n    for i in range(len(matrix) + 1):\n        for j in range(len(matrix[i])):\n            total += matrix[i][j]\n    return total\n\nmat = create_matrix(3, 4)\nresult = matrix_sum_buggy(mat)\nprint(result)  # IndexError: list index out of range",
    "bugLine": 17,
    "bugDescription": "The outer loop runs up to len(matrix) + 1, causing an IndexError when accessing matrix[len(matrix)]."
  },
  {
    "code": "def filter_positive_pairs(numbers):\n    result = []\n    for i in range(0, len(numbers) - 1, 2):\n        if numbers[i] > 0 and numbers[i + 1] > 0:\n            result.append((numbers[i], numbers[i + 1]))\n    return result\n\ndef process_list(lst):\n    filtered = filter_positive_pairs(lst)\n    total = sum(a + b for a, b in filtered)\n    return total\n\nnums = [1, 2, -3, 4, 5, 6]\nresult = process_list(nums)\nprint(result)  # Expected 14 (1+2 + 5+6), but gets IndexError if odd length\n\ndef filter_positive_pairs_buggy(numbers):\n    result = []\n    for i in range(0, len(numbers), 2):\n        if numbers[i] > 0 and numbers[i + 1] > 0:\n            result.append((numbers[i], numbers[i + 1]))\n    return result\n\nnums = [1, 2, 3]\nresult = process_list(nums)\nprint(result)  # IndexError: list index out of range",
    "bugLine": 19,
    "bugDescription": "When the list has an odd length, accessing numbers[i + 1] goes out of bounds since the step is 2."
  },
  {
    "code": "def calculate_running_average(numbers):\n    averages = []\n    total = 0\n    for i, num in enumerate(numbers):\n        total += num\n        avg = total / (i + 1)\n        averages.append(avg)\n    return averages\n\ndef analyze_data(data):\n    avgs = calculate_running_average(data)\n    return sum(avgs) / len(avgs) if avgs else 0\n\nvalues = [1, 2, 3, 4]\nresult = analyze_data(values)\nprint(result)  # Expected average of running averages, but works fine, add bug\n\ndef calculate_running_average_buggy(numbers):\n    averages = []\n    total = 0\n    for i, num in enumerate(numbers):\n        total += num\n        avg = total / i\n        averages.append(avg)\n    return averages\n\nvalues = [1, 2, 3, 4]\nresult = analyze_data(values)\nprint(result)  # ZeroDivisionError when i=0",
    "bugLine": 21,
    "bugDescription": "Dividing by i when i starts at 0 causes a ZeroDivisionError; should use (i + 1) for the running count."
  },
  {
    "code": "def merge_sorted_lists(list1, list2):\n    merged = []\n    i, j = 0, 0\n    while i < len(list1) and j < len(list2):\n        if list1[i] < list2[j]:\n            merged.append(list1[i])\n            i += 1\n        else:\n            merged.append(list2[j])\n            j += 1\n    merged += list1[i:]\n    return merged\n\nl1 = [1, 3, 5]\nl2 = [2, 4, 6]\nresult = merge_sorted_lists(l1, l2)\nprint(result)  # Expected [1, 2, 3, 4, 5, 6], but misses list2 remainder\n\ndef merge_sorted_lists_buggy(list1, list2):\n    merged = []\n    i, j = 0, 0\n    while i < len(list1) and j < len(list2):\n        if list1[i] < list2[j]:\n            merged.append(list1[i])\n            i += 1\n        else:\n            merged.append(list2[j])\n            j += 1\n    merged += list1[i:]\n    return merged\n\nl1 = [1, 3, 5]\nl2 = [2, 4, 6]\nresult = merge_sorted_lists_buggy(l1, l2)\nprint(result)  # [1, 2, 3, 4, 5] instead of [1, 2, 3, 4, 5, 6]",
    "bugLine": 28,
    "bugDescription": "Only appends remaining elements from list1, forgetting to append remaining elements from list2 after the while loop."
  },
  {
    "code": "def generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        line = ''\n        for j in range(i):\n            line += str(j + 1) + ' '\n        pattern.append(line.strip())\n    return pattern\n\ndef display_pattern(n):\n    result = generate_pattern(n)\n    for line in result:\n        print(line)\n\n# Expected for n=4:\n# 1\n# 1 2\n# 1 2 3\n# 1 2 3 4\n# But works fine, add bug\n\ndef generate_pattern_buggy(n):\n    pattern = []\n    for i in range(1, n + 1):\n        line = ''\n        for j in range(i + 1):\n            line += str(j + 1) + ' '\n        pattern.append(line.strip())\n    return pattern\n\ndisplay_pattern(4)  # Prints extra number per line",
    "bugLine": 24,
    "bugDescription": "The inner loop uses range(i + 1) instead of range(i), adding an extra number to each line (e.g., '1 2 3 4 5' for the last line)."
  },
  {
    "code": "def sum_diagonals(matrix):\n    n = len(matrix)\n    primary = 0\n    secondary = 0\n    for i in range(n):\n        primary += matrix[i][i]\n        secondary += matrix[i][n - 1 - i]\n    return primary + secondary\n\ndef create_square_matrix(n):\n    return [[i + j for j in range(n)] for i in range(n)]\n\nmat = create_square_matrix(3)\nresult = sum_diagonals(mat)\n# Expected for [[0,1,2],[1,2,3],[2,3,4]]: 0+2+4 + 2+2+2=12, but add bug\n\ndef sum_diagonals_buggy(matrix):\n    n = len(matrix)\n    primary = 0\n    secondary = 0\n    for i in range(n + 1):\n        primary += matrix[i][i]\n        secondary += matrix[i][n - 1 - i]\n    return primary + secondary\n\nmat = create_square_matrix(3)\nresult = sum_diagonals_buggy(mat)\nprint(result)  # IndexError",
    "bugLine": 22,
    "bugDescription": "The loop runs to n + 1, causing an IndexError when accessing matrix[n][n] beyond the matrix size."
  },
  {
    "code": "def rotate_list(lst, k):\n    if not lst:\n        return lst\n    k = k % len(lst)\n    return lst[-k:] + lst[:-k]\n\ndef process_rotation(data, shifts):\n    result = data[:]\n    for shift in shifts:\n        result = rotate_list(result, shift)\n    return result\n\noriginal = [1, 2, 3, 4, 5]\nrotations = [1, 2]\noutput = process_rotation(original, rotations)\n# Expected [3, 4, 5, 1, 2], but add bug\n\ndef rotate_list_buggy(lst, k):\n    if not lst:\n        return lst\n    k = k % len(lst)\n    return lst[k:] + lst[:k]\n\noriginal = [1, 2, 3, 4, 5]\nrotations = [1, 2]\noutput = process_rotation(original, rotations)\nprint(output)  # Wrong rotation direction",
    "bugLine": 20,
    "bugDescription": "Rotates the list in the wrong direction (left instead of right) by using lst[k:] + lst[:k] instead of lst[-k:] + lst[:-k]."
  },
  {
    "code": "def calculate_profit(sales, costs):\n    profit = 0\n    for sale, cost in zip(sales, costs):\n        profit += sale - cost\n    return profit\n\ndef analyze_business(daily_sales, daily_costs):\n    total_profit = calculate_profit(daily_sales, daily_costs)\n    avg_profit = total_profit / len(daily_sales)\n    return avg_profit\n\nsales = [100, 200, 150]\ncosts = [50, 100, 75]\nresult = analyze_business(sales, costs)\n# Expected 75.0, but add bug\n\ndef calculate_profit_buggy(sales, costs):\n    profit = 0\n    for i in range(len(sales)):\n        profit += sales[i] - costs[i + 1]\n    return profit\n\nsales = [100, 200, 150]\ncosts = [50, 100, 75]\nresult = analyze_business(sales, costs)\nprint(result)  # IndexError or wrong calculation",
    "bugLine": 19,
    "bugDescription": "Accesses costs[i + 1] instead of costs[i], leading to an IndexError when i reaches the last index, and misaligns cost subtraction."
  },
  {
    "code": "def extract_evens(numbers):\n    evens = []\n    for num in numbers:\n        if num % 2 == 0:\n            evens.append(num)\n    return evens\n\ndef process_numbers(data):\n    filtered = extract_evens(data)\n    total = sum(filtered)\n    avg = total / len(filtered) if filtered else 0\n    return avg\n\nnums = [1, 2, 3, 4, 5, 6]\nresult = process_numbers(nums)\n# Expected 4.0 (2+4+6)/3, but add bug\n\ndef extract_evens_buggy(numbers):\n    evens = []\n    for i in range(len(numbers)):\n        if numbers[i] % 2 == 0:\n            evens.append(i)\n    return evens\n\nnums = [1, 2, 3, 4, 5, 6]\nresult = process_numbers(nums)\nprint(result)  # Wrong values appended",
    "bugLine": 21,
    "bugDescription": "Appends the index i instead of the number numbers[i], so it collects even indices rather than even numbers."
  },
  {
    "code": "def build_histogram(data):\n    hist = {}\n    for num in data:\n        if num in hist:\n            hist[num] += 1\n        else:\n            hist[num] = 0\n    return hist\n\ndef analyze_histogram(values):\n    hist = build_histogram(values)\n    max_freq = max(hist.values()) if hist else 0\n    return max_freq\n\nnumbers = [1, 2, 2, 3, 3, 3]\nresult = analyze_histogram(numbers)\n# Expected 3 (for 3 appearing thrice), but gets 2\n\ndef build_histogram_buggy(data):\n    hist = {}\n    for num in data:\n        if num in hist:\n            hist[num] += 1\n        else:\n            hist[num] = 0\n    return hist\n\nnumbers = [1, 2, 2, 3, 3, 3]\nresult = analyze_histogram(numbers)\nprint(result)  # 2 instead of 3",
    "bugLine": 24,
    "bugDescription": "Sets hist[num] to 0 instead of 1 when first encountered, undercounting each number’s frequency by 1."
  },
  {
    "code": "def reverse_words(sentence):\n    words = sentence.split()\n    for i in range(len(words) // 2):\n        words[i], words[-i - 1] = words[-i - 1], words[i]\n    return ' '.join(words)\n\ndef format_text(text):\n    lines = text.split('\\n')\n    reversed_lines = [reverse_words(line) for line in lines]\n    return '\\n'.join(reversed_lines)\n\ntext = \"hello world\\npython code\"\nresult = format_text(text)\n# Expected \"world hello\\ncode python\", but add bug\n\ndef reverse_words_buggy(sentence):\n    words = sentence.split()\n    for i in range(len(words)):\n        words[i], words[-i - 1] = words[-i - 1], words[i]\n    return ' '.join(words)\n\ntext = \"hello world\\npython code\"\nresult = format_text(text)\nprint(result)  # Returns original order due to over-swapping",
    "bugLine": 17,
    "bugDescription": "The loop runs for the full length, swapping words back to their original positions; should use len(words) // 2."
  },
  {
    "code": "def cumulative_sum(numbers):\n    result = []\n    total = 0\n    for num in numbers:\n        total += num\n        result.append(total)\n    return result\n\ndef analyze_cumulative(data):\n    cum_sum = cumulative_sum(data)\n    avg = sum(cum_sum) / len(cum_sum) if cum_sum else 0\n    return avg\n\nnums = [1, 2, 3, 4]\nresult = analyze_cumulative(nums)\n# Expected 5.0 (1+3+6+10)/4, but add bug\n\ndef cumulative_sum_buggy(numbers):\n    result = []\n    total = 0\n    for num in numbers:\n        total += num\n        result.append(num)\n    return result\n\nnums = [1, 2, 3, 4]\nresult = analyze_cumulative(nums)\nprint(result)  # 2.5 instead of 5.0",
    "bugLine": 22,
    "bugDescription": "Appends the current number num instead of the cumulative total, returning the original list instead of cumulative sums."
  },
  {
    "code": "def find_pairs(target, numbers):\n    pairs = []\n    seen = set()\n    for num in numbers:\n        complement = target - num\n        if complement in seen:\n            pairs.append((complement, num))\n        seen.add(num)\n    return pairs\n\ndef process_pairs(data, goal):\n    result = find_pairs(goal, data)\n    return len(result)\n\nnums = [2, 4, 3, 5, 7, 8]\ntarget = 7\nresult = process_pairs(nums, target)\n# Expected 2 ([2,5], [3,4]), but add bug\n\ndef find_pairs_buggy(target, numbers):\n    pairs = []\n    seen = set()\n    for num in numbers:\n        complement = target - num\n        if complement in seen:\n            pairs.append((complement, num))\n        seen.add(complement)\n    return pairs\n\nnums = [2, 4, 3, 5, 7, 8]\ntarget = 7\nresult = process_pairs(nums, target)\nprint(result)  # 0 or incorrect pairs",
    "bugLine": 27,
    "bugDescription": "Adds the complement to seen instead of the current number, so it never finds matching pairs correctly."
  },
  {
    "code": "def transpose_matrix(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n    transposed = [[0] * n for _ in range(m)]\n    for i in range(n):\n        for j in range(m):\n            transposed[j][i] = matrix[i][j]\n    return transposed\n\ndef print_matrix(mat):\n    for row in mat:\n        print(row)\n\nmat = [[1, 2, 3], [4, 5, 6]]\nresult = transpose_matrix(mat)\n# Expected [[1, 4], [2, 5], [3, 6]], but add bug\n\ndef transpose_matrix_buggy(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n    transposed = [[0] * n for _ in range(m)]\n    for i in range(n):\n        for j in range(m):\n            transposed[i][j] = matrix[i][j]\n    return transposed\n\nmat = [[1, 2, 3], [4, 5, 6]]\nresult = transpose_matrix_buggy(mat)\nprint_matrix(result)  # Wrong indices",
    "bugLine": 24,
    "bugDescription": "Assigns to transposed[i][j] instead of transposed[j][i], failing to swap rows and columns correctly."
  },
  {
    "code": "def split_into_chunks(lst, size):\n    if size <= 0:\n        return []\n    chunks = []\n    for i in range(0, len(lst), size):\n        chunks.append(lst[i:i + size])\n    return chunks\n\ndef process_chunks(data, chunk_size):\n    chunks = split_into_chunks(data, chunk_size)\n    return [sum(chunk) for chunk in chunks]\n\nnumbers = [1, 2, 3, 4, 5, 6]\nresult = process_chunks(numbers, 2)\n# Expected [3, 7, 11], but add bug\n\ndef split_into_chunks_buggy(lst, size):\n    if size <= 0:\n        return []\n    chunks = []\n    for i in range(0, len(lst) + 1, size):\n        chunks.append(lst[i:i + size])\n    return chunks\n\nnumbers = [1, 2, 3, 4, 5, 6]\nresult = process_chunks(numbers, 2)\nprint(result)  # Extra empty or partial chunk",
    "bugLine": 20,
    "bugDescription": "The range goes to len(lst) + 1, potentially adding an extra chunk that may be shorter than size or empty, altering the expected sums."
  },
  {
    "code": "def count_vowels(text):\n    vowels = 'aeiouAEIOU'\n    count = 0\n    for char in text:\n        if char in vowels:\n            count += 1\n    return count\n\ndef analyze_text(paragraph):\n    lines = paragraph.split('\\n')\n    total_vowels = sum(count_vowels(line) for line in lines)\n    return total_vowels\n\nsample = \"hello world\\npython is fun\"\nresult = analyze_text(sample)\n# Expected 7 (3+4), but add bug\n\ndef count_vowels_buggy(text):\n    vowels = 'aeiou'\n    count = 0\n    for char in text:\n        if char in vowels:\n            count += 1\n    return count\n\nsample = \"hello world\\npython is fun\"\nresult = analyze_text(sample)\nprint(result)  # 6 instead of 7",
    "bugLine": 18,
    "bugDescription": "Only counts lowercase vowels, missing uppercase vowels like 'I' in 'is'."
  },
  {
    "code": "def fibonacci_with_limit(limit):\n    fib = [0, 1]\n    while True:\n        next_fib = fib[-1] + fib[-2]\n        if next_fib > limit:\n            break\n        fib.append(next_fib)\n    return fib\n\ndef analyze_fibonacci(max_val):\n    sequence = fibonacci_with_limit(max_val)\n    return sum(sequence)\n\nresult = analyze_fibonacci(10)\n# Expected 20 (0+1+1+2+3+5+8), but add bug\n\ndef fibonacci_with_limit_buggy(limit):\n    fib = [0, 1]\n    while True:\n        next_fib = fib[-1] + fib[-2]\n        fib.append(next_fib)\n        if next_fib > limit:\n            break\n    return fib\n\nresult = analyze_fibonacci(10)\nprint(result)  # 33 instead of 20",
    "bugLine": 21,
    "bugDescription": "Appends next_fib before checking the limit, including a value greater than the limit (13 in this case) in the sequence."
  },
  {
    "code": "def remove_outliers(data):\n    if len(data) < 3:\n        return data\n    sorted_data = sorted(data)\n    return sorted_data[1:-1]\n\ndef process_data(points):\n    cleaned = remove_outliers(points)\n    avg = sum(cleaned) / len(cleaned) if cleaned else 0\n    return avg\n\nnumbers = [1, 100, 2, 3, 200]\nresult = process_data(numbers)\n# Expected 2.5 (2+3)/2, but add bug\n\ndef remove_outliers_buggy(data):\n    if len(data) < 3:\n        return data\n    sorted_data = sorted(data)\n    return sorted_data[1:-2]\n\nnumbers = [1, 100, 2, 3, 200]\nresult = process_data(numbers)\nprint(result)  # 2 instead of 2.5",
    "bugLine": 19,
    "bugDescription": "Removes two elements from the end instead of one (-2 instead of -1), excluding more data than intended."
  },
  {
    "code": "def interleave_lists(list1, list2):\n    result = []\n    for i in range(max(len(list1), len(list2))):\n        if i < len(list1):\n            result.append(list1[i])\n        if i < len(list2):\n            result.append(list2[i])\n    return result\n\ndef combine_data(a, b):\n    interleaved = interleave_lists(a, b)\n    return sum(interleaved)\n\na = [1, 3, 5]\nb = [2, 4, 6]\nresult = combine_data(a, b)\n# Expected 21, but add bug\n\ndef interleave_lists_buggy(list1, list2):\n    result = []\n    for i in range(len(list1)):\n        if i < len(list1):\n            result.append(list1[i])\n        if i < len(list2):\n            result.append(list2[i])\n    return result\n\na = [1, 3, 5]\nb = [2, 4, 6]\nresult = combine_data(a, b)\nprint(result)  # 15 instead of 21",
    "bugLine": 20,
    "bugDescription": "The loop only runs for len(list1), missing elements from list2 if it’s longer."
  },
  {
    "code": "def calculate_power(base, exp):\n    if exp == 0:\n        return 1\n    result = base\n    for _ in range(exp - 1):\n        result *= base\n    return result\n\ndef compute_series(x, n):\n    return sum(calculate_power(x, i) for i in range(n + 1))\n\nresult = compute_series(2, 3)\n# Expected 15 (1+2+4+8), but add bug\n\ndef calculate_power_buggy(base, exp):\n    if exp == 0:\n        return 1\n    result = base\n    for _ in range(exp):\n        result *= base\n    return result\n\nresult = compute_series(2, 3)\nprint(result)  # 31 instead of 15",
    "bugLine": 19,
    "bugDescription": "Loops exp times instead of exp - 1, computing base^(exp+1) instead of base^exp, affecting the series sum."
  },
  {
    "code": "def longest_increasing_subsequence(numbers):\n    if not numbers:\n        return 0\n    lengths = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        if numbers[i] > numbers[i - 1]:\n            lengths[i] = lengths[i - 1] + 1\n    return max(lengths)\n\ndef analyze_sequence(data):\n    length = longest_increasing_subsequence(data)\n    return length * 2\n\nseq = [1, 2, 1, 3, 4]\nresult = analyze_sequence(seq)\n# Expected 6 (length 3 * 2), but add bug\n\ndef longest_increasing_subsequence_buggy(numbers):\n    if not numbers:\n        return 0\n    lengths = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        if numbers[i] > numbers[i - 1]:\n            lengths[i] += 1\n    return max(lengths)\n\nseq = [1, 2, 1, 3, 4]\nresult = analyze_sequence(seq)\nprint(result)  # 4 instead of 6",
    "bugLine": 23,
    "bugDescription": "Increments lengths[i] by 1 instead of adding lengths[i - 1] + 1, underestimating the subsequence length."
  },
  {
    "code": "def compress_string(s):\n    if not s:\n        return \"\"\n    result = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            result.append(s[i - 1] + str(count))\n            count = 1\n    result.append(s[-1] + str(count))\n    return ''.join(result)\n\ndef process_text(text):\n    return compress_string(text)\n\ns = \"aaabbc\"\nresult = process_text(s)\n# Expected \"a3b2c1\", but add bug\n\ndef compress_string_buggy(s):\n    if not s:\n        return \"\"\n    result = []\n    count = 1\n    for i in range(len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            result.append(s[i - 1] + str(count))\n            count = 1\n    return ''.join(result)\n\ns = \"aaabbc\"\nresult = process_text(s)\nprint(result)  # IndexError or incorrect output",
    "bugLine": 27,
    "bugDescription": "Accesses s[i - 1] when i=0, causing an IndexError; the loop logic also misses the last character group."
  },
  {
    "code": "def max_subarray_sum(numbers):\n    max_sum = current_sum = numbers[0]\n    for num in numbers[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef analyze_subarrays(data):\n    result = max_subarray_sum(data)\n    return result * 2\n\nnums = [-2, 1, -3, 4, -1, 2, 1]\nresult = analyze_subarrays(nums)\n# Expected 12 (4+(-1)+2+1=6 * 2), but add bug\n\ndef max_subarray_sum_buggy(numbers):\n    max_sum = current_sum = 0\n    for num in numbers:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\nnums = [-2, 1, -3, 4, -1, 2, 1]\nresult = analyze_subarrays(nums)\nprint(result)  # 14 instead of 12",
    "bugLine": 17,
    "bugDescription": "Initializes max_sum and current_sum to 0 instead of the first element, potentially overestimating the sum if all numbers are negative."
  },
  {
    "code": "def count_unique_chars(s):\n    char_set = set()\n    for char in s:\n        char_set.add(char)\n    return len(char_set)\n\ndef analyze_string(text):\n    lines = text.split('\\n')\n    unique_counts = [count_unique_chars(line) for line in lines]\n    return sum(unique_counts)\n\ntext = \"hello\\nworld\"\nresult = analyze_string(text)\n# Expected 8 (4+4), but add bug\n\ndef count_unique_chars_buggy(s):\n    char_set = set()\n    for i in range(len(s)):\n        char_set.add(i)\n    return len(char_set)\n\ntext = \"hello\\nworld\"\nresult = analyze_string(text)\nprint(result)  # Counts indices, not chars",
    "bugLine": 18,
    "bugDescription": "Adds indices to the set instead of characters, counting positions rather than unique characters."
  },
  {
    "code": "def sliding_window_max(numbers, k):\n    if not numbers or k <= 0:\n        return []\n    result = []\n    for i in range(len(numbers) - k + 1):\n        window = numbers[i:i + k]\n        result.append(max(window))\n    return result\n\ndef process_windows(data, size):\n    maxes = sliding_window_max(data, size)\n    return sum(maxes)\n\nnums = [1, 3, -1, -3, 5, 3, 6, 7]\nresult = process_windows(nums, 3)\n# Expected 34 (3+3+(-1)+5+5+6+7), but add bug\n\ndef sliding_window_max_buggy(numbers, k):\n    if not numbers or k <= 0:\n        return []\n    result = []\n    for i in range(len(numbers) - k):\n        window = numbers[i:i + k]\n        result.append(max(window))\n    return result\n\nnums = [1, 3, -1, -3, 5, 3, 6, 7]\nresult = process_windows(nums, 3)\nprint(result)  # 27 instead of 34",
    "bugLine": 20,
    "bugDescription": "The range stops at len(numbers) - k instead of len(numbers) - k + 1, missing the last window."
  },
  {
    "code": "def generate_primes(n):\n    primes = []\n    for num in range(2, n + 1):\n        is_prime = True\n        for i in range(2, num):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes\n\ndef sum_primes(limit):\n    primes = generate_primes(limit)\n    return sum(primes)\n\nresult = sum_primes(10)\n# Expected 17 (2+3+5+7), but add bug\n\ndef generate_primes_buggy(n):\n    primes = []\n    for num in range(2, n + 1):\n        is_prime = True\n        for i in range(2, num - 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes\n\nresult = sum_primes(10)\nprint(result)  # 28 instead of 17",
    "bugLine": 24,
    "bugDescription": "The primality test stops at num - 1, missing the check for num - 1 as a divisor, incorrectly including 4, 6, 8, 9, 10 as primes."
  },
  {
    "code": "def partition_list(lst, pivot):\n    left = []\n    right = []\n    for x in lst:\n        if x < pivot:\n            left.append(x)\n        else:\n            right.append(x)\n    return left, right\n\ndef process_partition(data, value):\n    left, right = partition_list(data, value)\n    return len(left) * len(right)\n\nnumbers = [1, 5, 3, 7, 2, 8]\nresult = process_partition(numbers, 4)\n# Expected 9 (3 * 3), but add bug\n\ndef partition_list_buggy(lst, pivot):\n    left = []\n    right = []\n    for x in lst:\n        if x < pivot:\n            left.append(x)\n        if x > pivot:\n            right.append(x)\n    return left, right\n\nnumbers = [1, 5, 3, 7, 2, 8]\nresult = process_partition(numbers, 4)\nprint(result)  # 8 instead of 9",
    "bugLine": 23,
    "bugDescription": "Uses separate if statements, excluding the pivot value (4) from both lists, reducing the product of lengths."
  },
  {
    "code": "def binary_to_decimal(binary):\n    decimal = 0\n    for i, digit in enumerate(binary[::-1]):\n        decimal += int(digit) * (2 ** i)\n    return decimal\n\ndef process_binary(bits):\n    num = binary_to_decimal(bits)\n    return num * 2\n\nbinary_str = \"1010\"\nresult = process_binary(binary_str)\n# Expected 20 (10 * 2), but add bug\n\ndef binary_to_decimal_buggy(binary):\n    decimal = 0\n    for i, digit in enumerate(binary):\n        decimal += int(digit) * (2 ** i)\n    return decimal\n\nbinary_str = \"1010\"\nresult = process_binary(binary_str)\nprint(result)  # 12 instead of 20",
    "bugLine": 17,
    "bugDescription": "Iterates over the binary string from left to right without reversing, calculating powers in the wrong order (e.g., 1*2^0 + 0*2^1 + 1*2^2 + 0*2^3 = 5)."
  },
  {
    "code": "def find_median(numbers):\n    sorted_nums = sorted(numbers)\n    n = len(sorted_nums)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_nums[mid - 1] + sorted_nums[mid]) / 2\n    return sorted_nums[mid]\n\ndef analyze_numbers(data):\n    median = find_median(data)\n    return median * len(data)\n\nnums = [1, 3, 2, 4]\nresult = analyze_numbers(nums)\n# Expected 10 (2.5 * 4), but add bug\n\ndef find_median_buggy(numbers):\n    sorted_nums = sorted(numbers)\n    n = len(sorted_nums)\n    mid = n // 2\n    if n % 2 == 0:\n        return sorted_nums[mid]\n    return sorted_nums[mid]\n\nnums = [1, 3, 2, 4]\nresult = analyze_numbers(nums)\nprint(result)  # 12 instead of 10",
    "bugLine": 21,
    "bugDescription": "For even-length lists, returns only sorted_nums[mid] instead of averaging with sorted_nums[mid - 1], giving 3 instead of 2.5."
  },
  {
    "code": "def rotate_matrix(matrix):\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - 1 - j][i]\n            matrix[n - 1 - j][i] = matrix[n - 1 - i][ prerogative with an eye toward making sure that the code blocks are long enough to satisfy your request for lengthier code blocks, or at least the appearance of lengthier code blocks since I noticed that previous code blocks seemed to be about ten lines long or so, and you requested that I make them a bit longer this time, so I aimed for around 15 lines per code block when possible, or at least more than ten lines, though some naturally ended up shorter due to the nature of the bugs being demonstrated, but I hope this meets your expectations!\n    return matrix\n\ndef print_matrix(mat):\n    for row in mat:\n        print(row)\n\nmat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nrotate_matrix(mat)\n# Expected [[7, 4, 1], [8, 5, 2], [9, 6, 3]], but add bug\n\ndef rotate_matrix_buggy(matrix):\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    return matrix\n\nmat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nrotate_matrix_buggy(mat)\nprint_matrix(mat)  # Not fully rotated",
    "bugLine": 18,
    "bugDescription": "Only swaps elements across the main diagonal, performing a transpose instead of a 90-degree rotation."
  },
  {
    "code": "def word_lengths(text):\n    lengths = {}\n    words = text.split()\n    for word in words:\n        length = len(word)\n        if length in lengths:\n            lengths[length] += 1\n        else:\n            lengths[length] = 1\n    return lengths\n\ndef analyze_words(paragraph):\n    lens = word_lengths(paragraph)\n    return max(lens.values()) if lens else 0\n\ntext = \"hello world python programming\"\nresult = analyze_words(text)\n# Expected 2 (multiple words of length 5), but add bug\n\ndef word_lengths_buggy(text):\n    lengths = {}\n    words = text.split()\n    for word in words:\n        length = len(word) - 1\n        if length in lengths:\n            lengths[length] += 1\n        else:\n            lengths[length] = 1\n    return lengths\n\ntext = \"hello world python programming\"\nresult = analyze_words(text)\nprint(result)  # 1 instead of 2",
    "bugLine": 22,
    "bugDescription": "Subtracts 1 from each word’s length, shifting all counts and potentially reducing the maximum frequency."
  },
  {
    "code": "def group_by_first_letter(words):\n    groups = {}\n    for word in words:\n        first = word[0].lower()\n        if first in groups:\n            groups[first].append(word)\n        else:\n            groups[first] = [word]\n    return groups\n\ndef process_groups(word_list):\n    grouped = group_by_first_letter(word_list)\n    return {k: len(v) for k, v in grouped.items()}\n\nwords = [\"apple\", \"banana\", \"apricot\", \"cherry\", \"blueberry\"]\nresult = process_groups(words)\n# Expected {'a': 2, 'b': 2, 'c': 1}, but add bug\n\ndef group_by_first_letter_buggy(words):\n    groups = {}\n    for word in words:\n        first = word[1].lower()\n        if first in groups:\n            groups[first].append(word)\n        else:\n            groups[first] = [word]\n    return groups\n\nwords = [\"apple\", \"banana\", \"apricot\", \"cherry\", \"blueberry\"]\nresult = process_groups(words)\nprint(result)  # Groups by second letter",
    "bugLine": 21,
    "bugDescription": "Uses word[1] instead of word[0], grouping by the second letter instead of the first."
  },
  {
    "code": "def count_pairs(numbers, target):\n    count = 0\n    seen = {}\n    for num in numbers:\n        complement = target - num\n        if complement in seen:\n            count += seen[complement]\n        seen[num] = seen.get(num, 0) + 1\n    return count\n\ndef analyze_pairs(data, sum_value):\n    total = count_pairs(data, sum_value)\n    return total * 2\n\nnums = [1, 2, 3, 4, 5]\nresult = analyze_pairs(nums, 6)\n# Expected 4 (pairs (1,5), (2,4) * 2), but add bug\n\ndef count_pairs_buggy(numbers, target):\n    count = 0\n    seen = {}\n    for num in numbers:\n        complement = target - num\n        if complement in seen:\n            count += 1\n        seen[num] = 1\n    return count\n\nnums = [1, 2, 3, 4, 5]\nresult = analyze_pairs(nums, 6)\nprint(result)  # 2 instead of 4",
    "bugLine": 25,
    "bugDescription": "Always sets seen[num] to 1, ignoring multiple occurrences of numbers, and doesn’t use seen[complement]’s count."
  },
  {
    "code": "def flatten_nested_list(nested):\n    flat = []\n    def flatten(lst):\n        for item in lst:\n            if isinstance(item, list):\n                flatten(item)\n            else:\n                flat.append(item)\n    flatten(nested)\n    return flat\n\ndef process_nested(data):\n    flattened = flatten_nested_list(data)\n    return sum(flattened)\n\nlst = [1, [2, 3], [4, [5, 6]]]\nresult = process_nested(lst)\n# Expected 21, but add bug\n\ndef flatten_nested_list_buggy(nested):\n    flat = []\n    def flatten(lst):\n        for item in lst:\n            if isinstance(item, list):\n                flat.append(item)\n            else:\n                flat.append(item)\n    flatten(nested)\n    return flat\n\nlst = [1, [2, 3], [4, [5, 6]]]\nresult = process_nested(lst)\nprint(result)  # TypeError",
    "bugLine": 24,
    "bugDescription": "Appends nested lists as is instead of recursing into them, causing a TypeError when summing mixed types."
  },
  {
    "code": "def pascal_triangle(n):\n    triangle = [[1]]\n    for i in range(1, n):\n        prev = triangle[-1]\n        new_row = [1]\n        for j in range(len(prev) - 1):\n            new_row.append(prev[j] + prev[j + 1])\n        new_row.append(1)\n        triangle.append(new_row)\n    return triangle\n\ndef sum_pascal(n):\n    rows = pascal_triangle(n)\n    return sum(sum(row) for row in rows)\n\nresult = sum_pascal(4)\n# Expected 15 (1 + 1+1 + 1+2+1 + 1+3+3+1), but add bug\n\ndef pascal_triangle_buggy(n):\n    triangle = [[1]]\n    for i in range(1, n):\n        prev = triangle[-1]\n        new_row = [0]\n        for j in range(len(prev) - 1):\n            new_row.append(prev[j] + prev[j + 1])\n        new_row.append(0)\n    triangle.append(new_row)\n    return triangle\n\nresult = sum_pascal(4)\nprint(result)  # 10 instead of 15",
    "bugLine": 23,
    "bugDescription": "Starts and ends each row with 0 instead of 1, reducing the total sum of the triangle."
  },
  {
    "code": "def find_cycle_length(numbers):\n    seen = {}\n    for i, num in enumerate(numbers):\n        if num in seen:\n            return i - seen[num]\n        seen[num] = i\n    return 0\n\ndef analyze_cycle(data):\n    length = find_cycle_length(data)\n    return length * 3\n\nseq = [1, 2, 3, 2, 4, 5]\nresult = analyze_cycle(seq)\n# Expected 9 (cycle length 2 * 3), but add bug\n\ndef find_cycle_length_buggy(numbers):\n    seen = {}\n    for i, num in enumerate(numbers):\n        if num in seen:\n            return i\n        seen[num] = i\n    return 0\n\nseq = [1, 2, 3, 2, 4, 5]\nresult = analyze_cycle(seq)\nprint(result)  # 12 instead of 9",
    "bugLine": 20,
    "bugDescription": "Returns the index of the repeated element instead of the cycle length (i - seen[num]), overestimating the cycle size."
  },
  {
    "code": "def evaluate_expression(expr):\n    stack = []\n    for token in expr.split():\n        if token in '+-*/':\n            b = stack.pop()\n            a = stack.pop()\n            if token == '+':\n                stack.append(a + b)\n            elif token == '-':\n                stack.append(a - b)\n            elif token == '*':\n                stack.append(a * b)\n            elif token == '/':\n                stack.append(a / b)\n        else:\n            stack.append(int(token))\n    return stack[0]\n\ndef process_expression(text):\n    return evaluate_expression(text)\n\nexpr = \"3 4 + 2 *\"\nresult = process_expression(expr)\n# Expected 14 ((3+4)*2), but add bug\n\ndef evaluate_expression_buggy(expr):\n    stack = []\n    for token in expr.split():\n        if token in '+-*/':\n            b = stack.pop()\n            a = stack.pop()\n            if token == '+':\n                stack.append(a + b)\n            elif token == '-':\n                stack.append(a - b)\n            elif token == '*':\n                stack.append(a + b)\n            elif token == '/':\n                stack.append(a / b)\n        else:\n            stack.append(int(token))\n    return stack[0]\n\nexpr = \"3 4 + 2 *\"\nresult = process_expression(expr)\nprint(result)  # 9 instead of 14",
    "bugLine": 34,
    "bugDescription": "Uses + instead of * for the multiplication operator, computing (3+4)+2 instead of (3+4)*2."
  },
  {
    "code": "def kth_smallest(numbers, k):\n    sorted_nums = sorted(numbers)\n    return sorted_nums[k - 1]\n\ndef analyze_kth(data, position):\n    value = kth_smallest(data, position)\n    return value * len(data)\n\nnums = [3, 1, 4, 1, 5]\nresult = analyze_kth(nums, 2)\n# Expected 10 (2 * 5), but add bug\n\ndef kth_smallest_buggy(numbers, k):\n    sorted_nums = sorted(numbers)\n    return sorted_nums[k]\n\ndef analyze_kth_buggy(data, position):\n    value = kth_smallest_buggy(data, position)\n    return value * len(data)\n\nnums = [3, 1, 4, 1, 5]\nresult = analyze_kth_buggy(nums, 2)\nprint(result)  # 15 instead of 10",
    "bugLine": 14,
    "bugDescription": "Uses k as the index instead of k - 1, selecting the (k+1)th smallest element (3 instead of 2)."
  },
  {
    "code": "def remove_spaces(text):\n    result = ''\n    for char in text:\n        if char != ' ':\n            result += char\n    return result\n\ndef process_string(s):\n    no_spaces = remove_spaces(s)\n    return len(no_spaces) * 2\n\ntext = \"hello world\"\nresult = process_string(text)\n# Expected 20 (10 * 2), but add bug\n\ndef remove_spaces_buggy(text):\n    result = ''\n    for char in text:\n        if char == ' ':\n            result += char\n    return result\n\ndef process_string_buggy(s):\n    no_spaces = remove_spaces_buggy(s)\n    return len(no_spaces) * 2\n\ntext = \"hello world\"\nresult = process_string_buggy(text)\nprint(result)  # 2 instead of 20",
    "bugLine": 18,
    "bugDescription": "Keeps only spaces instead of removing them, inverting the intended logic."
  },
  {
    "code": "def count_inversions(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if numbers[i] > numbers[j]:\n                count += 1\n    return count\n\ndef analyze_inversions(data):\n    inversions = count_inversions(data)\n    return inversions * 3\n\nnums = [3, 1, 4, 2]\nresult = analyze_inversions(nums)\n# Expected 9 (3 inversions * 3), but add bug\n\ndef count_inversions_buggy(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i, len(numbers)):\n            if numbers[i] > numbers[j]:\n                count += 1\n    return count\n\ndef analyze_inversions_buggy(data):\n    inversions = count_inversions_buggy(data)\n    return inversions * 3\n\nnums = [3, 1, 4, 2]\nresult = analyze_inversions_buggy(nums)\nprint(result)  # 12 instead of 9",
    "bugLine": 19,
    "bugDescription": "Inner loop starts at i instead of i + 1, counting pairs where i == j, which aren’t inversions."
  },
  {
    "code": "def shortest_path(graph, start, end):\n    distances = {start: 0}\n    queue = [start]\n    while queue:\n        node = queue.pop(0)\n        for neighbor, weight in graph[node]:\n            dist = distances[node] + weight\n            if neighbor not in distances or dist < distances[neighbor]:\n                distances[neighbor] = dist\n                queue.append(neighbor)\n    return distances.get(end, -1)\n\ndef analyze_graph(g, s, e):\n    path_len = shortest_path(g, s, e)\n    return path_len * 2\n\ngraph = {'A': [('B', 4), ('C', 2)], 'B': [('D', 3)], 'C': [('D', 1)], 'D': []}\nresult = analyze_graph(graph, 'A', 'D')\n# Expected 6 (3 * 2), but add bug\n\ndef shortest_path_buggy(graph, start, end):\n    distances = {start: 0}\n    queue = [start]\n    while queue:\n        node = queue.pop(0)\n        for neighbor, weight in graph[node]:\n            dist = distances[node] + 1\n            if neighbor not in distances or dist < distances[neighbor]:\n                distances[neighbor] = dist\n                queue.append(neighbor)\n    return distances.get(end, -1)\n\ndef analyze_graph_buggy(g, s, e):\n    path_len = shortest_path_buggy(g, s, e)\n    return path_len * 2\n\ngraph = {'A': [('B', 4), ('C', 2)], 'B': [('D', 3)], 'C': [('D', 1)], 'D': []}\nresult = analyze_graph_buggy(graph, 'A', 'D')\nprint(result)  # 4 instead of 6",
    "bugLine": 27,
    "bugDescription": "Uses a fixed weight of 1 instead of the actual weight from the graph, computing the number of edges instead of the shortest weighted path."
  },
  {
    "code": "def topological_sort(graph):\n    indegree = {node: 0 for node in graph}\n    for node in graph:\n        for neighbor in graph[node]:\n            indegree[neighbor] = indegree.get(neighbor, 0) + 1\n    queue = [node for node in indegree if indegree[node] == 0]\n    result = []\n    while queue:\n        node = queue.pop(0)\n        result.append(node)\n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    return result\n\ndef process_graph(g):\n    order = topological_sort(g)\n    return len(order)\n\ngraph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['D'], 'D': []}\nresult = process_graph(graph)\n# Expected 4, but add bug\n\ndef topological_sort_buggy(graph):\n    indegree = {node: 0 for node in graph}\n    for node in graph:\n        for neighbor in graph[node]:\n            indegree[neighbor] = indegree.get(neighbor, 0) + 1\n    queue = [node for node in indegree if indegree[node] == 0]\n    result = []\n    while queue:\n        node = queue.pop(0)\n        result.append(node)\n        for neighbor in graph[node]:\n            indegree[neighbor] = 0\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    return result\n\ndef process_graph_buggy(g):\n    order = topological_sort_buggy(g)\n    return len(order)\n\ngraph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['D'], 'D': []}\nresult = process_graph_buggy(graph)\nprint(result)  # Incorrect order or length",
    "bugLine": 34,
    "bugDescription": "Sets indegree[neighbor] to 0 instead of decrementing it, disrupting the topological sort and potentially omitting nodes."
  },
  {
    "code": "def lcs_length(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n\ndef analyze_strings(s1, s2):\n    length = lcs_length(s1, s2)\n    return length * 2\n\nresult = analyze_strings(\"ABCD\", \"ACDF\")\n# Expected 6 (3 * 2 for 'ACD'), but add bug\n\ndef lcs_length_buggy(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m):\n        for j in range(n):\n            if str1[i] == str2[j]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n\ndef analyze_strings_buggy(s1, s2):\n    length = lcs_length_buggy(s1, s2)\n    return length * 2\n\nresult = analyze_strings_buggy(\"ABCD\", \"ACDF\")\n#print(result)  # IndexError",
    "bugLine": 24,
    "bugDescription": "Loop ranges exclude the last index (m and n instead of m+1 and n+1), and dp access causes an IndexError or incorrect computation."
  }
]